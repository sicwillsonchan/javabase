# Object的公共方法

## protected Object	clone() 

创建并返回此对象的一个副本。

## boolean	equals(Object obj) 

指示其他某个对象是否与此对象“相等”。

## protected void	finalize() 

当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。

## Class getClass() 

返回此 Object 的运行时类。

## int	hashCode() 



总的来说，Java中的集合（Collection）有两类，一类 是List，再有一类是Set。前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？这就是Object.equals方法了。但是，如果每增加一个元素就检查一 次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它 就要调用1000次equals方法。这显然会大大降低效率。 于是，Java采用了哈希表的原理。哈希算法也称为散列算法，是 将数据依特定算法直接指定到一个地址上。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以 直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散 列其它的地址。所以这里存在一个冲突解决的问题。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。 所以，Java对于eqauls方法和hashCode方法是这样规定的：

1、如果两个对象相同，那么它们的hashCode值一定要相同； 　

2、如果两个对象的hashCode相同，它们并不一定相同

## void	notify() 

唤醒在此对象监视器上等待的单个线程。

## void	notifyAll() 

唤醒在此对象监视器上等待的所有线程。

## String	toString() 

返回该对象的字符串表示。

## void	wait() 

在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待。

## void	wait(long timeout) 

在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量前，导致当前线程等待。

## void	wait(long timeout, int nanos) 

在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。